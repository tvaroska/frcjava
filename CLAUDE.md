# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an FRC (FIRST Robotics Competition) 2025 Java robot project using WPILib's command-based framework with a swerve drive system powered by CTRE Phoenix 6 hardware (TalonFX motors and CANcoders).

### Vendor Dependencies

Required vendordeps (located in `vendordeps/`):
- **Phoenix6-frc2025-latest.json** - CTRE Phoenix 6 library for TalonFX motors, CANcoders, and Pigeon 2
- **AdvantageKit.json** - AdvantageKit for advanced telemetry and logging
- **WPILibNewCommands.json** - WPILib command-based framework

## Essential Commands

### Build and Deploy
- `./gradlew build` - Compile and run tests
- `./gradlew deploy` - Build and deploy code to the RoboRIO
- `./gradlew clean` - Clean build artifacts

### Testing
- `./gradlew test` - Run JUnit 5 tests
  - Tests located in `src/test/java/frc/robot/`
  - Current coverage: RobotContainer initialization and Telemetry publishing

### Simulation
- `./gradlew simulateJava` - Run robot code in simulation with GUI enabled by default
- Driver Station is automatically added to simulation

### Useful Tools
- `./gradlew SysId` - Launch WPILib's System Identification tool for characterization
- `./gradlew Glass` - Launch Glass for telemetry visualization
- `./gradlew ShuffleBoard` - Launch Shuffleboard dashboard

## Architecture

### Command-Based Structure

The project follows WPILib's command-based paradigm:

- **Robot.java** - Extends `TimedRobot`, manages mode transitions and periodic execution
- **RobotContainer.java** - Central configuration hub: instantiates subsystems, binds controller inputs to commands
  - Note: `getAutonomousCommand()` method removed - autonomous setup should be added here when needed
- **Subsystems** - Located in `frc.robot.subsystems/`, each encapsulates hardware and provides command factories
- **Commands** - Defined inline in `RobotContainer` using the Commands API and method references

### Swerve Drive Implementation

The swerve drivetrain is built on CTRE Phoenix 6 libraries:

- **CommandSwerveDrivetrain** - Main subsystem extending CTRE's `SwerveDrivetrain` and WPILib's `Subsystem`
- **TunerConstants.java** (generated) - Contains hardware IDs, PID gains, gear ratios, module positions, and encoder offsets
  - Generated by Tuner X - modifications should be done via Tuner X tool
  - Creates module constants for 4 swerve modules (FrontLeft, FrontRight, BackLeft, BackRight)
- **ModuleConstants.java** - Additional module-level configuration

Hardware configuration:
- 4 swerve modules, each with TalonFX drive motor, TalonFX steer motor, CANcoder absolute encoder
- Pigeon 2 IMU (CAN ID 24) for heading
- All devices on "rio" CAN bus
- Top speed: 4.99 m/s at 12V

### Control Bindings (Xbox Controller)

Default driver controls configured in `RobotContainer.configureBindings()`:
- Left stick: Translation (X/Y movement) with slew rate limiting (3 units/sec)
- Right stick X: Rotation with slew rate limiting
- X button: Brake mode (point wheels in X formation)
- Right bumper: Point wheels toward stick direction
- Left bumper: Reset field-centric heading
- Back+Y/X: SysId dynamic characterization
- Start+Y/X: SysId quasistatic characterization

### Constants Organization

- **Constants.java** - Application constants (currently only controller port)
- **TunerConstants.java** - Hardware-specific swerve configuration (DO NOT manually edit - use Tuner X)

### Vision Integration

`CommandSwerveDrivetrain` provides `addVisionMeasurement()` methods for fusing vision pose estimates with odometry using a Kalman filter.

## Important Development Notes

### Generated Files

Files in `frc.robot.generated/` are generated by CTRE Tuner X:
- Do not manually edit `TunerConstants.java` or `ModuleConstants.java`
- Use Tuner X to modify PID gains, module positions, gear ratios, or hardware IDs
- Re-generate after hardware changes

### Simulation

- Simulation automatically starts at 200 Hz (5ms loop period) when `Utils.isSimulation()` is true
- Simulation GUI and DriverStation are configured in `build.gradle`
- Desktop support is enabled (`includeDesktopSupport = true`)
- Common simulation warnings (can be ignored):
  - "Joystick Button X on port 0 not available" - No controller plugged in
  - "CAN frame not received/too-stale" - Simulated devices may not respond immediately
  - "Loop time overrun" - Simulation periodic taking longer than 20ms during initialization

### Alliance-Aware Operation

The drivetrain automatically adjusts operator perspective based on alliance color:
- Blue alliance: 0° is toward red wall
- Red alliance: 180° is toward blue wall
- Applied in `periodic()` when disabled or on first run

### Team Number Configuration

Team number is loaded from `.wpilib/wpilib_preferences.json` or command line, required for deployment.

### Java Version

Project requires Java 17 (source and target compatibility set in `build.gradle`).

### Telemetry

AdvantageKit is installed as a vendordep but currently not actively used (Robot extends `TimedRobot`, not `LoggedRobot`). The `Telemetry` class uses CTRE's SignalLogger for swerve drivetrain data logging via `drivetrain.registerTelemetry()`.

### Testing Strategy

The project includes minimal unit tests to verify core functionality:
- **RobotContainerTest** - Validates robot initialization, drivetrain setup, and command scheduler execution
- **TelemetryTest** - Verifies telemetry can publish swerve drive state without errors

Tests use HAL simulation and run automatically with `./gradlew test` or `./gradlew build`.
